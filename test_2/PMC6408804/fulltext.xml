<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.1 20151215//EN" "JATS-archivearticle1.dtd"> 
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article"><?properties open_access?><?DTDIdentifier.IdentifierValue -//Springer-Verlag//DTD A++ V2.4//EN?><?DTDIdentifier.IdentifierType public?><?SourceDTD.DTDName A++V2.4.dtd?><?SourceDTD.Version 2.4?><?ConverterInfo.XSLTName springer2nlmx2.xsl?><?ConverterInfo.Version 1?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id><journal-title-group><journal-title>BMC Bioinformatics</journal-title></journal-title-group><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name><publisher-loc>London</publisher-loc></publisher></journal-meta><article-meta><article-id pub-id-type="pmcid">6408804</article-id><article-id pub-id-type="publisher-id">2698</article-id><article-id pub-id-type="doi">10.1186/s12859-019-2698-4</article-id><article-categories><subj-group subj-group-type="heading"><subject>Methodology Article</subject></subj-group></article-categories><title-group><article-title>JOA: Joint Overlap Analysis of multiple genomic interval sets</article-title></title-group><contrib-group><contrib contrib-type="author" corresp="yes"><contrib-id contrib-id-type="orcid">http://orcid.org/0000-0002-4931-7979</contrib-id><name><surname>Otlu</surname><given-names>Bur&#x000e7;ak</given-names></name><address><email>burcak@ceng.metu.edu.tr</email></address><xref ref-type="aff" rid="Aff1"/></contrib><contrib contrib-type="author"><name><surname>Can</surname><given-names>Tolga</given-names></name><address><email>tcan@ceng.metu.edu.tr</email></address><xref ref-type="aff" rid="Aff1"/></contrib><aff id="Aff1"><institution-wrap><institution-id institution-id-type="ISNI">0000 0001 1881 7391</institution-id><institution-id institution-id-type="GRID">grid.6935.9</institution-id><institution>Department of Computer Engineering, Middle East Technical University, </institution></institution-wrap>Ankara, 06800 Turkey </aff></contrib-group><pub-date pub-type="epub"><day>8</day><month>3</month><year>2019</year></pub-date><pub-date pub-type="pmc-release"><day>8</day><month>3</month><year>2019</year></pub-date><pub-date pub-type="collection"><year>2019</year></pub-date><volume>20</volume><elocation-id>121</elocation-id><history><date date-type="received"><day>9</day><month>3</month><year>2018</year></date><date date-type="accepted"><day>21</day><month>2</month><year>2019</year></date></history><permissions><copyright-statement>&#x000a9; The Author(s) 2019</copyright-statement><license license-type="OpenAccess"><license-p><bold>Open Access</bold> This article is distributed under the terms of the Creative Commons Attribution 4.0 International License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons license, and indicate if changes were made. The Creative Commons Public Domain Dedication waiver (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</ext-link>) applies to the data made available in this article, unless otherwise stated.</license-p></license></permissions><abstract id="Abs1"><sec><title>Background</title><p>Next-generation sequencing (NGS) technologies have produced large volumes of genomic data. One common operation on heterogeneous genomic data is genomic interval intersection. Most of the existing tools impose restrictions such as not allowing nested intervals or requiring intervals to be sorted when finding overlaps in two or more interval sets.</p></sec><sec><title>Results</title><p>We proposed segment tree (ST) and indexed segment tree forest (ISTF) based solutions for intersection of multiple genomic interval sets in parallel. We developed these methods as a tool, Joint Overlap Analysis (JOA), which takes <italic>n</italic> interval sets and finds overlapping intervals with no constraints on the given intervals. The proposed indexed segment tree forest is a novel composite data structure, which leverages on indexing and natural binning of a segment tree. We also presented construction and search algorithms for this novel data structure. We compared JOA ST and JOA ISTF with each other, and with other interval intersection tools for verification of its correctness and for showing that it attains comparable execution times.</p></sec><sec><title>Conclusions</title><p>We implemented JOA in Java using the fork/join framework which speeds up parallel processing by taking advantage of all available processor cores. We compared JOA ST with JOA ISTF and showed that segment tree and indexed segment tree forest methods are comparable with each other in terms of execution time and memory usage. We also carried out execution time comparison analysis for JOA and other tools and demonstrated that JOA has comparable execution time and is able to further reduce its running time by using more processors per node. JOA can be run using its GUI or as a command line tool. JOA is available with source code at <ext-link ext-link-type="uri" xlink:href="https://github.com/burcakotlu/JOA/">https://github.com/burcakotlu/JOA/</ext-link>. A user manual is provided at <ext-link ext-link-type="uri" xlink:href="https://joa.readthedocs.org">https://joa.readthedocs.org</ext-link></p></sec><sec><title>Electronic supplementary material</title><p>The online version of this article (10.1186/s12859-019-2698-4) contains supplementary material, which is available to authorized users.</p></sec></abstract><kwd-group xml:lang="en"><title>Keywords</title><kwd>Genome analysis</kwd><kwd>Joint overlap analysis</kwd><kwd>Interval overlap</kwd><kwd>Interval intersection</kwd><kwd>Genomic interval intersection</kwd><kwd>Segment tree</kwd><kwd>Indexed segment tree forest</kwd><kwd>Space partitioning algorithms</kwd></kwd-group><custom-meta-group><custom-meta><meta-name>issue-copyright-statement</meta-name><meta-value>&#x000a9; The Author(s) 2019</meta-value></custom-meta></custom-meta-group></article-meta></front><body><sec id="Sec1"><title>Background</title><p>Genomic interval intersection is a major component of analysis pipelines for Next Generation Sequencing (NGS) technologies such as RNASeq, ChIPSeq, and exome sequencing. There are various existing tools that perform interval intersection [<xref ref-type="bibr" rid="CR1">1</xref>&#x02013;<xref ref-type="bibr" rid="CR5">5</xref>] and many other genomic analyses. UCSC Genome Browser has been continuously improved since its first launch. Lately, the Data Integrator feature is released in UCSC Genome Browser, which allows users to combine and extract data from multiple tracks (up to 5 tracks), simultaneously [<xref ref-type="bibr" rid="CR1">1</xref>]. BEDTools is a toolset developed for genomics analysis tasks such as comparison, manipulation, and annotation of genomic features in BAM, BED, GFF and VCF formats [<xref ref-type="bibr" rid="CR2">2</xref>]. Pybedtools extends upon BEDTools and provides a Python interface for BEDTools [<xref ref-type="bibr" rid="CR3">3</xref>].</p><p>BEDOPS is a highly scalable and easily-parallelizable genome analysis toolkit, which enables tasks to be easily split by chromosome for distributing whole-genome analyses across a computational cluster [<xref ref-type="bibr" rid="CR4">4</xref>]. BEDOPS requires sorted interval set files before intersection. GROK utilizes region algebra for genomic region operations and provides R, Python, LUA, command line interfaces, and C++ API extension [<xref ref-type="bibr" rid="CR5">5</xref>]. NCList uses a novel data structure named Nested Containment List (NCList) for interval databases [<xref ref-type="bibr" rid="CR6">6</xref>]. NCList keeps intervals in lists such that intervals in each list have containment relation. However, no list fully contains one another, which implies that if lists are ordered on their start positions, then they are also sorted on their end positions. GLANET stands for genomic loci annotation and enrichment tool and provides joint overlap analysis of 2 to 3 tracks at most [<xref ref-type="bibr" rid="CR7">7</xref>].</p><p>Layer et al. propose a novel parallel &#x0201c;slice-then-sweep&#x0201d; algorithm for <italic>n</italic>-way interval set intersection. Their algorithm requires the input intervals not to be contained fully in one another [<xref ref-type="bibr" rid="CR8">8</xref>]. Tabix indexes tab-delimited files and converts a sequential access file into a random access file [<xref ref-type="bibr" rid="CR9">9</xref>].</p><p>In this paper, we generalize the problem of genomic interval intersection (finding common overlapping intervals) from 2 or 3 interval sets to <italic>n</italic> interval sets. We implement segment tree based construction and search algorithms in parallel for each interval set and chromosome. We accept <italic>n</italic> interval sets in Browser Extensible Data (BED) format and we apply a divide and conquer algorithm for finding common overlapping intervals. The intervals in a single set may overlap, may contain one another, and may be unsorted. We divide the interval sets into two sets, recursively, until one or two interval sets remain as base cases. In case of two interval sets, we construct a segment tree from one of the interval sets and we then search the intervals of the other interval set as query intervals on the constructed segment tree. In case of one interval set, we return all of its intervals as overlapping intervals. Results coming from the base cases are combined as follows: one of the results is used as query intervals, a segment tree is built on the other result, query intervals are searched on the segment tree, and overlapping intervals are returned. This process is repeated recursively until all of the <italic>n</italic> interval sets are processed.</p><p>We also propose a composite data structure, indexed segment tree forest which leverages on natural binning of segment trees and indexing the segment tree nodes at a certain depth. The same divide and conquer algorithm is also applied on the indexed segment tree forest (ISTF). However, this time when a segment tree is constructed, we proceed by converting this segment tree to an indexed segment tree forest by cutting this tree at a certain depth and indexing the segment tree nodes at that cut-off level. Our aim is to reduce the search space and search on the shorter indexed segment tree forest rather than one tall segment tree and eventually to reduce the query time. The overview of the proposed methodology is depicted in Fig.&#x000a0;<xref rid="Fig1" ref-type="fig">1</xref>.
<fig id="Fig1"><label>Fig. 1</label><caption><p>Work-flow for finding jointly overlapping intervals of <italic>n</italic> interval sets, displays the proposed data structures: segment tree and indexed segment tree forest, and the key steps on them</p></caption><graphic xlink:href="12859_2019_2698_Fig1_HTML" id="MO1"/></fig>
</p></sec><sec id="Sec2" sec-type="results"><title>Results</title><sec id="Sec3"><title>Execution time comparison</title><p>We compared JOA with other tools using their latest available versions such as GROK v1.1.1, BEDTools v2.27.1, and BEDOPS 2.4.35. To compare the tools, we have used real and semi-synthetic datasets. As an additional case study, we compared JOA segment tree and JOA indexed segment tree forest using 141 ENCODE Dnase hypersensitive sites. Details of these datasets can be found in Availability of data and material.</p><p>During comparisons, JOA is run both with segment tree (ST) and indexed segment tree forest (ISTF) options, GROK is run through its python API and intersectionL method is utilized, BEDTools is called by its intersect -a -b utility, and for BEDOPS, &#x02013;intersect set operation is used. BEDTools is run with its &#x0201c;multiinter&#x0201d; parameter when there are more than 2 input files. BEDTools gives a number to each input file starting at 1, when run with the &#x0201c;multiinter&#x0201d; parameter and produces a comma separated list of the input file numbers that are jointly overlapping in the fifth column of its output file. Therefore, from BEDTools&#x02019; output file, we counted the number of rows that has all the file numbers separated by comma in the fifth column and calculated the number of jointly overlapping intervals.</p><p>All of the runs are carried out on Centos 6.6, Intel Xeon Gold 6132 (skylake), 2.6GHz &#x000d7;28 processors (14 cores/socket). All the provided execution times in Tables&#x000a0;<xref rid="Tab1" ref-type="table">1</xref>, <xref rid="Tab2" ref-type="table">2</xref>, <xref rid="Tab3" ref-type="table">3</xref> and <xref rid="Tab4" ref-type="table">4</xref> are averaged over 50 runs.
<table-wrap id="Tab1"><label>Table 1</label><caption><p>Average execution time comparison of the tools for the six benchmarks</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Benchmarks</th><th align="left" colspan="7">Average execution times in seconds</th></tr><tr><th align="left"/><th align="left" colspan="5">(1n,1ppn)</th><th align="left" colspan="2">(1n,8ppn)</th></tr><tr><th align="left"/><th align="left">GROK</th><th align="left">BEDOPS</th><th align="left">BEDTools</th><th align="left">JOA ST</th><th align="left">JOA ISTF</th><th align="left">JOA ST</th><th align="left">JOA ISTF</th></tr></thead><tbody><tr><td align="left">2 small files</td><td align="left">1.1426</td><td align="left">0.1785</td><td align="left">0.4204</td><td align="left">1.5135</td><td align="left">1.7880</td><td align="left">0.8363</td><td align="left">0.9712</td></tr><tr><td align="left">5 small files</td><td align="left">2.3757</td><td align="left">0.3104</td><td align="left">12.6509</td><td align="left">2.1504</td><td align="left">2.7396</td><td align="left">1.2470</td><td align="left">1.5531</td></tr><tr><td align="left">(2.3M, 2.3M)</td><td align="left">13.5173</td><td align="left">1.8656</td><td align="left">14.4679</td><td align="left">16.1611</td><td align="left">17.0239</td><td align="left">9.5708</td><td align="left">9.7355</td></tr><tr><td align="left">(6.4M, 6.4M)</td><td align="left">34.2736</td><td align="left">4.8053</td><td align="left">63.8499</td><td align="left">39.7799</td><td align="left">43.5383</td><td align="left">23.9280</td><td align="left">24.0116</td></tr><tr><td align="left">(9.2M, 9.2M)</td><td align="left">54.5452</td><td align="left">7.1102</td><td align="left">65.3324</td><td align="left">56.0001</td><td align="left">55.9838</td><td align="left">31.7290</td><td align="left">32.5613</td></tr><tr><td align="left">(6.4M, 9.2M)</td><td align="left">49.2007</td><td align="left">5.4660</td><td align="left">43.1104</td><td align="left">48.0046</td><td align="left">47.9815</td><td align="left">23.2048</td><td align="left">24.3927</td></tr></tbody></table><table-wrap-foot><p>GROK, JOA, BEDTools and BEDOPS execution times are averaged over 50 runs</p></table-wrap-foot></table-wrap><table-wrap id="Tab2"><label>Table 2</label><caption><p>Number of interval files are increased by two fold whereas number of intervals in each file is kept constant</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Simulations 1<sup><italic>s</italic><italic>t</italic></sup> Scenario (#ofFiles,#ofIntervals)</th><th align="left" colspan="7">Average execution times in seconds</th></tr><tr><th align="left"/><th align="left" colspan="5">(1n,1ppn)</th><th align="left" colspan="2">(1n,2ppn)</th></tr><tr><th align="left"/><th align="left">GROK</th><th align="left">BEDOPS</th><th align="left">BEDTools</th><th align="left">JOA ST</th><th align="left">JOA ISTF</th><th align="left">JOA ST</th><th align="left">JOA ISTF</th></tr></thead><tbody><tr><td align="left">(2,100000)</td><td align="left">0.6973</td><td align="left">0.0366</td><td align="left">0.2380</td><td align="left">1.0846</td><td align="left">1.2861</td><td align="left">0.6677</td><td align="left">0.7121</td></tr><tr><td align="left">(4,100000)</td><td align="left">1.3527</td><td align="left">0.0397</td><td align="left">3.8666</td><td align="left">1.4480</td><td align="left">1.7342</td><td align="left">1.0410</td><td align="left">1.0932</td></tr><tr><td align="left">(8,100000)</td><td align="left">2.7232</td><td align="left">0.0447</td><td align="left">8.2620</td><td align="left">2.0175</td><td align="left">2.4720</td><td align="left">1.4686</td><td align="left">1.5197</td></tr><tr><td align="left">(16,100000)</td><td align="left">5.7325</td><td align="left">0.0565</td><td align="left">18.9487</td><td align="left">2.8402</td><td align="left">3.6387</td><td align="left">2.0252</td><td align="left">2.3860</td></tr><tr><td align="left">(32,100000)</td><td align="left">12.5799</td><td align="left">0.0819</td><td align="left">45.7564</td><td align="left">4.4840</td><td align="left">5.4132</td><td align="left">3.0647</td><td align="left">3.6630</td></tr><tr><td align="left">(64,100000)</td><td align="left">30.2584</td><td align="left">0.1283</td><td align="left">116.7736</td><td align="left">6.9214</td><td align="left">7.9966</td><td align="left">4.5746</td><td align="left">5.4844</td></tr><tr><td align="left">(128,100000)</td><td align="left">66.7122</td><td align="left">0.2131</td><td align="left">312.8438</td><td align="left">12.1682</td><td align="left">13.6740</td><td align="left">7.4285</td><td align="left">8.3240</td></tr><tr><td align="left">(256,100000)</td><td align="left">-</td><td align="left">0.4229</td><td align="left">891.2454</td><td align="left">22.6010</td><td align="left">24.0628</td><td align="left">15.3915</td><td align="left">16.2595</td></tr><tr><td align="left">(512,100000)</td><td align="left">-</td><td align="left">0.8283</td><td align="left">2887.3816</td><td align="left">42.0187</td><td align="left">45.3321</td><td align="left">26.9868</td><td align="left">28.8161</td></tr></tbody></table><table-wrap-foot><p>Average execution time comparison of the tools for the first scenario using semi-synthetic datasets. GROK, JOA, BEDTools and BEDOPS execution times are averaged over 50 runs except BEDTools runs for 128, 256 and 512 files which are averaged over 2 runs</p></table-wrap-foot></table-wrap><table-wrap id="Tab3"><label>Table 3</label><caption><p>Number of intervals in each file is increased by two fold whereas number of interval files is kept constant</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Simulations 2<sup><italic>n</italic><italic>d</italic></sup> Scenario (#ofFiles,#ofIntervals)</th><th align="left" colspan="7">Average execution times in seconds</th></tr><tr><th align="left"/><th align="left" colspan="5">(1n,1ppn)</th><th align="left" colspan="2">(1n,2ppn)</th></tr><tr><th align="left"/><th align="left">GROK</th><th align="left">BEDOPS</th><th align="left">BEDTools</th><th align="left">JOA ST</th><th align="left">JOA ISTF</th><th align="left">JOA ST</th><th align="left">JOA ISTF</th></tr></thead><tbody><tr><td align="left">(2,1M)</td><td align="left">9.0330</td><td align="left">0.3635</td><td align="left">4.2109</td><td align="left">4.5382</td><td align="left">5.2108</td><td align="left">3.4880</td><td align="left">4.1231</td></tr><tr><td align="left">(2,2M)</td><td align="left">19.7827</td><td align="left">0.6202</td><td align="left">11.4695</td><td align="left">11.8475</td><td align="left">12.2080</td><td align="left">7.2478</td><td align="left">8.2213</td></tr><tr><td align="left">(2,4M)</td><td align="left">44.9517</td><td align="left">1.8149</td><td align="left">33.1372</td><td align="left">29.9437</td><td align="left">32.5128</td><td align="left">18.4192</td><td align="left">19.3616</td></tr><tr><td align="left">(2,8M)</td><td align="left">102.6299</td><td align="left">2.9645</td><td align="left">108.0360</td><td align="left">73.2382</td><td align="left">74.9382</td><td align="left">55.1262</td><td align="left">56.9878</td></tr><tr><td align="left">(2,16M)</td><td align="left">255.6354</td><td align="left">5.7609</td><td align="left">397.5899</td><td align="left">190.2903</td><td align="left">192.3511</td><td align="left">178.7225</td><td align="left">185.8660</td></tr></tbody></table><table-wrap-foot><p>Average execution time comparison of the tools for the second scenario of semi-synthetic datasets. GROK, JOA, BEDTools and BEDOPS execution times are averaged over 50 runs</p></table-wrap-foot></table-wrap><table-wrap id="Tab4"><label>Table 4</label><caption><p>Average execution time comparison of JOA ST and ISTF for 141 interval sets of Dnase hypersensitive sites</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">ENCODE 141 DHSs files</th><th align="left" colspan="2">Average execution times in seconds</th></tr><tr><th align="left"/><th align="left">(1n,1ppn)</th><th align="left">(1n,8ppn)</th></tr></thead><tbody><tr><td align="left">JOA ST</td><td align="left">15.8894</td><td align="left">9.6301</td></tr><tr><td align="left">JOA ISTF</td><td align="left">19.0009</td><td align="left">10.6943</td></tr></tbody></table><table-wrap-foot><p>JOA ST and ISTF execution times are averaged over 50 runs. Average execution times are reduced as number of processors per node is increased from 1 to 8</p></table-wrap-foot></table-wrap>
</p><p>There exists other tools and formats such as BGT, GQT, SeqArray and BGEN [<xref ref-type="bibr" rid="CR10">10</xref>&#x02013;<xref ref-type="bibr" rid="CR13">13</xref>] that requires joint overlap analysis. BGT is a new, compact file format for efficiently storing and querying whole-genome genotypes of tens to hundreds of thousands of samples. BGT search alleles/variants in the input bgt format file within a given site or list of sites [<xref ref-type="bibr" rid="CR10">10</xref>]. Genotype Query Tools (GQT) is a new indexing strategy that expedites analyses of genome variation datasets in VCF format based on sample genotypes, phenotypes and relationships [<xref ref-type="bibr" rid="CR11">11</xref>]. SeqArray is a storage-efficient high-performance new data format for WGS variant calls which comes with SeqArray software package including key R functions [<xref ref-type="bibr" rid="CR12">12</xref>]. BGEN is another novel binary file format for imputed genotype and haplotype data which are supported by many tools[<xref ref-type="bibr" rid="CR13">13</xref>]. BGT, SeqArray and BGEN introduce their own new data format and carry out analysis on their new data formats except GQT, which carries out analysis on the VCF format. However, JOA does not support these data formats but designed for text based formats including &#x0201c;.bed&#x0201d; and &#x0201c;.pk&#x02019; formats. Therefore, we did not compare JOA against them.</p><sec id="Sec4"><title>Execution time comparison of tools using benchmarks datasets</title><p>JOA ST and ISTF are run for both (1 node, 1 processor per node) and (1 node, 8 processors per node) settings. Average execution times are listed in Table&#x000a0;<xref rid="Tab1" ref-type="table">1</xref>. Running times are comparable and usage of more processors per node decreased the running time of JOA because of parallel implementation of ST and ISTF algorithms. For &#x0201c;5 small files&#x0201d;, BEDTools &#x0201c;multiinter&#x0201d; parameter usage increased its running time as it has a different implementation which is also reflected in its output. Number of overlapping intervals found for each benchmark dataset is listed in Table&#x000a0;<xref rid="Tab5" ref-type="table">5</xref>. JOA and BEDTools found exactly the same number of overlapping intervals whereas GROK and BEDOPS found different number of overlapping intervals. This might be because of a different design, implementation or a case which is handled differently such as nested intervals.
<table-wrap id="Tab5"><label>Table 5</label><caption><p>Number of overlapping intervals found for each benchmark</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Benchmarks</th><th align="left" colspan="5">Number of overlapping intervals found</th></tr><tr><th align="left"/><th align="left">GROK</th><th align="left">BEDOPS</th><th align="left">BEDTools</th><th align="left">JOA ST</th><th align="left">JOA ISTF</th></tr></thead><tbody><tr><td align="left">2 small files</td><td align="left">145925</td><td align="left">145925</td><td align="left">145925</td><td align="left">145925</td><td align="left">145925</td></tr><tr><td align="left">5 small files</td><td align="left">93080</td><td align="left">93080</td><td align="left">93080</td><td align="left">93080</td><td align="left">93080</td></tr><tr><td align="left">(2.3M, 2.3M)</td><td align="left">2972223</td><td align="left">753639</td><td align="left">13903684</td><td align="left">13903684</td><td align="left">13903684</td></tr><tr><td align="left">(6.4M, 6.4M)</td><td align="left">7369608</td><td align="left">1292747</td><td align="left">47936947</td><td align="left">47936947</td><td align="left">47936947</td></tr><tr><td align="left">(9.2M, 9.2M)</td><td align="left">11553395</td><td align="left">3046101</td><td align="left">39217773</td><td align="left">39217773</td><td align="left">39217773</td></tr><tr><td align="left">(6.4M, 9.2M)</td><td align="left">4746709</td><td align="left">424074</td><td align="left">19645676</td><td align="left">19645676</td><td align="left">19645676</td></tr></tbody></table><table-wrap-foot><p>JOA and BEDTools found exactly the same number of overlapping intervals whereas GROK and BEDOPS found different number of overlapping intervals</p></table-wrap-foot></table-wrap>
</p></sec><sec id="Sec5"><title>Execution time comparison of tools using semi-synthetic datasets</title><p>To compare the tools on a controlled dataset, we uniformly sampled 500bp long intervals from the human genome and generated bed format input. In the first scenario, we kept the number of intervals constant at 100,000 in each file and we increased the number of files by twofold from 2 to 512. In the second scenario, we kept the number of files constant at 2 and we increased the number of intervals in each file by twofold from 1,000,000 to 16,000,000.</p><p>In the firs scenario, we could not run GROK for more than 256 input files since calling a python function with more than 256 arguments was not allowed. Also, in the first scenario, BEDTools is called with the &#x0201c;multiinter&#x0201d; parameter when there are more than two input files.</p><p>Average execution times for both scenarios are provided in Tables&#x000a0;<xref rid="Tab2" ref-type="table">2</xref> and <xref rid="Tab3" ref-type="table">3</xref>. In the first scenario, when the number of input files is greater than 2, BEDTools average execution times are extremely high because of the &#x0201c;multiinter&#x0201d; option usage. In both scenarios, JOA has reduced execution times when 2 processors per node (ppn) is used instead of 1 ppn.</p><p>The number of overlapping intervals found for the first scenario and the second scenario are provided in Tables&#x000a0;<xref rid="Tab6" ref-type="table">6</xref> and <xref rid="Tab7" ref-type="table">7</xref>, respectively. JOA and BEDTools found the same number of overlapping intervals for the semi-synthetic datasets as in the case of benchmark datasets. However, GROK and BEDOPS found different number of overlapping intervals.
<table-wrap id="Tab6"><label>Table 6</label><caption><p>Number of overlapping intervals found by the tools for the first scenario of semi-synthetic datasets</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Simulations 1<sup><italic>s</italic><italic>t</italic></sup> Scenario (#ofFiles,#ofIntervals)</th><th align="left" colspan="5">Number of Overlapping Intervals Found</th></tr><tr><th align="left"/><th align="left">GROK</th><th align="left">BEDOPS</th><th align="left">BEDTools</th><th align="left">JOA ST</th><th align="left">JOA ISTF</th></tr></thead><tbody><tr><td align="left">(2,100000)</td><td align="left">3958</td><td align="left">3761</td><td align="left">3913</td><td align="left">3913</td><td align="left">3913</td></tr><tr><td align="left">(4,100000)</td><td align="left">5</td><td align="left">5</td><td align="left">5</td><td align="left">5</td><td align="left">5</td></tr><tr><td align="left">(8,100000)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">(16,100000)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">(32,100000)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">(64,100000)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">(128,100000)</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">(256,100000)</td><td align="left">-</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">(512,100000)</td><td align="left">-</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr></tbody></table></table-wrap><table-wrap id="Tab7"><label>Table 7</label><caption><p>Number of overlapping intervals found by the tools for the second scenario of semi-synthetic datasets</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Simulations 2<sup><italic>n</italic><italic>d</italic></sup> Scenario (#ofFiles,#ofIntervals)</th><th align="left" colspan="5">Number of Overlapping Intervals Found</th></tr><tr><th align="left"/><th align="left">GROK</th><th align="left">BEDOPS</th><th align="left">BEDTools</th><th align="left">JOA ST</th><th align="left">JOA ISTF</th></tr></thead><tbody><tr><td align="left">(2,1M)</td><td align="left">432665</td><td align="left">280649</td><td align="left">402931</td><td align="left">402931</td><td align="left">402931</td></tr><tr><td align="left">(2,2M)</td><td align="left">1741459</td><td align="left">804859</td><td align="left">1613107</td><td align="left">1613107</td><td align="left">1613107</td></tr><tr><td align="left">(2,4M)</td><td align="left">6509486</td><td align="left">1785275</td><td align="left">6455690</td><td align="left">6455690</td><td align="left">6455690</td></tr><tr><td align="left">(2,8M)</td><td align="left">20936796</td><td align="left">2706065</td><td align="left">25812190</td><td align="left">25812190</td><td align="left">25812190</td></tr><tr><td align="left">(2,16M)</td><td align="left">55354698</td><td align="left">2336735</td><td align="left">103245490</td><td align="left">103245490</td><td align="left">103245490</td></tr></tbody></table></table-wrap>
</p></sec><sec id="Sec6"><title>Execution time comparison of JOA ST versus ISTF using ENCODE data</title><p>To show the parallel processing advantage of JOA, we designed and ran an additional case study for JOA using 141 interval sets of Dnase hypersensitive sites. We found and supplied all jointly overlapping intervals for these 141 interval sets in Additional file&#x000a0;<xref rid="MOESM1" ref-type="media">1</xref>: Table S1. This additional case study verified that JOA can handle a significantly larger number of interval files and JOA is able to attain better running times with the help of its parallel processing ability as shown in Table&#x000a0;<xref rid="Tab4" ref-type="table">4</xref>.</p></sec></sec><sec id="Sec7"><title>JOA segment tree versus indexed segment tree forest detailed execution time comparison</title><p>We used the last four benchmarks (2.3M, 2.3M), (6.4M, 6.4M), (9.2M, 9.2M), and (6.4M, 9.2M) from benchmarks datasets in Table&#x000a0;<xref rid="Tab1" ref-type="table">1</xref>. We compared JOA ST versus JOA ISTF with respect to read, construction and query running times which are averaged over 50 runs. We show that ST and ISTF perform comparably with respect to read, construction and query running times as it is shown in Fig.&#x000a0;<xref rid="Fig2" ref-type="fig">2</xref>.
<fig id="Fig2"><label>Fig. 2</label><caption><p>We compare JOA segment tree and indexed segment tree forest w.r.t. read, construction and query time which are averaged over 50 runs. This comparison shows that segment tree and indexed segment tree forest are comparable to each other</p></caption><graphic xlink:href="12859_2019_2698_Fig2_HTML" id="MO2"/></fig>
</p></sec><sec id="Sec8"><title>JOA memory usage</title><p>Segment tree requires <inline-formula id="IEq1"><alternatives><tex-math id="M1">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {O}(nlog{n})$\end{document}</tex-math><mml:math id="M2"><mml:mi mathvariant="script">O</mml:mi><mml:mo>(</mml:mo><mml:mtext mathvariant="italic">nlogn</mml:mtext><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2019_2698_Article_IEq1.gif"/></alternatives></inline-formula> storage for <italic>n</italic> given intervals. Since indexed segment tree forest is based on indexing of segment tree nodes at a certain depth, it has similar memory requirements. JOA is implemented in Java with fork/join framework which speeds up parallel processing by using all available processor cores. However, parallel processing requires loading all the data into memory. Also, segment tree and indexed segment tree forest construction requires memory allocation of many temporary data structures which can be only deallocated automatically by the Java garbage collector.</p><p>We calculated the memory usage of JOA ST and ISTF for the semi-synthetic datasets. The memory usage in megabytes (MBs) are presented in Additional file&#x000a0;<xref rid="MOESM2" ref-type="media">2</xref>: Tables S2 and S3. All the memory usage in the first and second scenarios are as expected; however, for the 2 interval sets of 8M intervals each, and for the 2 interval sets of 16M intervals in the second scenario, JOA&#x02019;s memory consumption is high. This can be the due to the loading all interval sets into memory, the additional temporarily used data structures, or the Java garbage collector. As long as Java Virtual Machine has enough memory, garbage collector may not take action to deallocate memory and follow manually written memory deallocation statements in the code.</p></sec></sec><sec id="Sec9" sec-type="discussion"><title>Discussion</title><p>Parallel implementation of JOA ST and JOA ISTF algorithms require all the input intervals to be loaded into the memory. Moreover, JAVA garbage collector deallocates memory automatically without taking manually written memory deallocations into account. Therefore, although JOA ST and JOA ISTF have comparable and sometimes lower execution times, their memory footprint may be high.</p><p>Regarding JOA ISTF, we analyzed how the percentage parameter affects the cut-off depth and how the cut-off depth affects the execution time (Figs.&#x000a0;<xref rid="Fig3" ref-type="fig">3</xref> and <xref rid="Fig4" ref-type="fig">4</xref>). Depending on these analyses, we set the percentage parameter to 0.5<italic>%</italic>. In addition to that, we provided a detailed analysis on the average height of the binary search trees (BSTs) constructed from hash indexes. We showed that average height of BSTs is always less than or equal the height of the original segment tree.
<fig id="Fig3"><label>Fig. 3</label><caption><p>We analyze the effect of percentage parameter on the average cut-off depth and the number of intervals that require extra work. This analysis shows that as we increase the percentage parameter, as expected, the number of intervals that need to be moved increases and average cut-off depth decreases</p></caption><graphic xlink:href="12859_2019_2698_Fig3_HTML" id="MO3"/></fig><fig id="Fig4"><label>Fig. 4</label><caption><p>We analyze the effect of percentage parameter on the average runtimes. These runtimes are averaged over 50 runs using 2.3 million intervals files. This analysis shows that as we increase the percentage parameter, as expected, average read time does not change but the construction time and query time are increased</p></caption><graphic xlink:href="12859_2019_2698_Fig4_HTML" id="MO4"/></fig>
</p><p>Furthermore, for JOA ISTF, we analyzed the number of hash indexes for varying preset values using human genome, chromosome 1 intervals of the 5 small files&#x02019; which is provided as the second benchmark dataset in Table&#x000a0;<xref rid="Tab1" ref-type="table">1</xref>. The smaller the preset value, the higher the number of different hash indexes, and vice versa (Fig.&#x000a0;<xref rid="Fig5" ref-type="fig">5</xref>).
<fig id="Fig5"><label>Fig. 5</label><caption><p>Number of hash indexes for varying preset values. Preset values must be multiplied by 10K</p></caption><graphic xlink:href="12859_2019_2698_Fig5_HTML" id="MO5"/></fig>
</p><p>Moreover, we computed the mean and standard deviation of the number of segment tree nodes assigned to the same hash index as we vary the preset value. The smaller the preset value, the less the number of segment tree nodes assigned to a hash index (Fig.&#x000a0;<xref rid="Fig6" ref-type="fig">6</xref>). This shows that there is a trade off between number of hash indexes and the mean number of segment tree nodes assigned to a hash index as we change the preset value. This is an inherent advantage of the proposed indexed segment tree forest construction algorithm and allows for generalizing to varying preset values.
<fig id="Fig6"><label>Fig. 6</label><caption><p>Mean and standard deviation of number of segment tree nodes assigned to hash indexes for varying preset values. Preset values must be multiplied by 10K</p></caption><graphic xlink:href="12859_2019_2698_Fig6_HTML" id="MO6"/></fig>
</p></sec><sec id="Sec10" sec-type="conclusion"><title>Conclusion</title><p>In this paper, we presented efficient methods for parallel joint overlap analysis of <italic>n</italic> interval sets. The proposed segment tree and novel indexed segment tree forest solutions are optimized with a divide and conquer algorithm design and implemented as a tool named JOA. We showed that JOA ST and ISTF have comparable execution times. We compared JOA with other state of the art tools such as GROK, BEDTools, BEDOPS and demonstrated the efficacy of JOA with respect to the execution time. Especially, when the number of processors per node is increased, JOA had less execution time than the other tools. Furthermore, we also verified that JOA is able to identify all the overlapping intervals.</p><p>To verify the parallel processing advantage of JOA, we designed and ran an additional case study for JOA in which we found the jointly overlapping intervals of 141 interval sets of ENCODE Dnase hypersensitive sites.</p></sec><sec id="Sec11"><title>Methods</title><sec id="Sec12"><title>Segment tree</title><p>Similar to interval trees, segment tree data structure is another well-known space partitioning tree and a data structure for storing intervals. Its space complexity is <inline-formula id="IEq2"><alternatives><tex-math id="M3">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {O}(nlog{n})$\end{document}</tex-math><mml:math id="M4"><mml:mi mathvariant="script">O</mml:mi><mml:mo>(</mml:mo><mml:mtext mathvariant="italic">nlogn</mml:mtext><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2019_2698_Article_IEq2.gif"/></alternatives></inline-formula> and it can be constructed in <inline-formula id="IEq3"><alternatives><tex-math id="M5">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {O}(nlog{n})$\end{document}</tex-math><mml:math id="M6"><mml:mi mathvariant="script">O</mml:mi><mml:mo>(</mml:mo><mml:mtext mathvariant="italic">nlogn</mml:mtext><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2019_2698_Article_IEq3.gif"/></alternatives></inline-formula> time for <italic>n</italic> given intervals. Finding all intervals in the segment tree containing a query point <italic>q</italic><sub><italic>x</italic></sub> requires <inline-formula id="IEq4"><alternatives><tex-math id="M7">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {O}(log{n}+k)$\end{document}</tex-math><mml:math id="M8"><mml:mi mathvariant="script">O</mml:mi><mml:mo>(</mml:mo><mml:mtext mathvariant="italic">logn</mml:mtext><mml:mo>+</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2019_2698_Article_IEq4.gif"/></alternatives></inline-formula> time for <italic>n</italic> given intervals and <italic>k</italic> hits [<xref ref-type="bibr" rid="CR14">14</xref>].</p><p>Let <inline-formula id="IEq5"><alternatives><tex-math id="M9">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$I := {[x_{1} : x^{\prime }_{1}], [x_{2} : x^{\prime }_{2} ],..., [x_{n} : x^{\prime }_{n}]}$\end{document}</tex-math><mml:math id="M10"><mml:mi>I</mml:mi><mml:mo>:</mml:mo><mml:mo>=</mml:mo><mml:mo>[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mo>&#x02032;</mml:mo></mml:mrow></mml:msubsup><mml:mo>]</mml:mo><mml:mo>,</mml:mo><mml:mo>[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mo>&#x02032;</mml:mo></mml:mrow></mml:msubsup><mml:mo>]</mml:mo><mml:mo>,</mml:mo><mml:mi>...</mml:mi><mml:mo>,</mml:mo><mml:mo>[</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mrow><mml:mo>&#x02032;</mml:mo></mml:mrow></mml:msubsup><mml:mo>]</mml:mo></mml:math><inline-graphic xlink:href="12859_2019_2698_Article_IEq5.gif"/></alternatives></inline-formula> be a set of <italic>n</italic> given intervals on the real line. Let <italic>p</italic><sub>1</sub>,<italic>p</italic><sub>2</sub>,...,<italic>p</italic><sub><italic>m</italic></sub> be the list of distinct interval endpoints (low and high endpoints), sorted from left to right. We simply partition the real line induced by these endpoints <italic>p</italic><sub><italic>i</italic></sub>. We name the regions in this partitioning as elementary intervals. Thus, the elementary intervals from these endpoints <italic>p</italic><sub>1</sub>, <italic>p</italic><sub>2</sub>, &#x02026;, <italic>p</italic><sub><italic>m</italic>&#x02212;1</sub>, <italic>p</italic><sub><italic>m</italic></sub> are, from left to right, [<italic>p</italic><sub>1</sub>:<italic>p</italic><sub>1</sub>],(<italic>p</italic><sub>1</sub>:<italic>p</italic><sub>2</sub>),[<italic>p</italic><sub>2</sub>:<italic>p</italic><sub>2</sub>],...,(<italic>p</italic><sub><italic>m</italic>&#x02212;1</sub>:<italic>p</italic><sub><italic>m</italic></sub>),[<italic>p</italic><sub><italic>m</italic></sub>:<italic>p</italic><sub><italic>m</italic></sub>].</p><p>To this end, we build a binary search tree <italic>T</italic> whose leaves correspond to these elementary intervals induced by the endpoints of the intervals in <italic>I</italic> in an ordered way: the leftmost leaf corresponds to the leftmost elementary interval, and so on. We denote the elementary interval corresponding to a leaf <italic>&#x003bc;</italic> by <italic>Int</italic>(<italic>&#x003bc;</italic>).</p><p>An internal node of <italic>T</italic> represents the intervals that are the union of intervals of its two children: <italic>Int</italic>(<italic>&#x003bd;</italic>) corresponding to node <italic>&#x003bd;</italic> is the union of the intervals <italic>Int</italic>(<italic>&#x003bd;</italic><sub><italic>leftChild</italic></sub>) and <italic>Int</italic>(<italic>&#x003bd;</italic><sub><italic>rightChild</italic></sub>) in the subtree rooted at <italic>&#x003bd;</italic>. The interval represented by the parent of leaf nodes, <italic>Int</italic>(<italic>&#x003bd;</italic>), is the union of the elementary intervals <italic>Int</italic>(<italic>&#x003bd;</italic><sub><italic>leftChild</italic></sub>) and <italic>Int</italic>(<italic>&#x003bd;</italic><sub><italic>rightChild</italic></sub>). Note that elementary intervals are different from the input intervals, <italic>I</italic>.</p><p>Each internal node <italic>&#x003bd;</italic> in <italic>T</italic> represents an interval <italic>Int</italic>(<italic>&#x003bd;</italic>) whereas each leaf node <italic>&#x003bc;</italic> represents an elementary interval, <italic>Int</italic>(<italic>&#x003bc;</italic>). Each node stores a subset of input intervals, i.e., the canonical subset, <italic>I</italic>(<italic>&#x003bd;</italic>), where <italic>I</italic>(<italic>&#x003bd;</italic>)&#x02286;<italic>I</italic>. This canonical subset of node <italic>&#x003bd;</italic> stores the intervals [<italic>x</italic>:<italic>x</italic><sup>&#x02032;</sup>]&#x02208;<italic>I</italic> such that <italic>Int</italic>(<italic>&#x003bd;</italic>)&#x02286;[<italic>x</italic>:<italic>x</italic><sup>&#x02032;</sup>] and <italic>Int</italic>(<italic>parent</italic>(<italic>&#x003bd;</italic>))&#x02ac5;&#x00338;[<italic>x</italic>:<italic>x</italic><sup>&#x02032;</sup>]. This implies that if interval [<italic>x</italic>:<italic>x</italic><sup>&#x02032;</sup>] is in the canonical subset of node <italic>&#x003bd;</italic>, <italic>I</italic>(<italic>&#x003bd;</italic>), then <italic>Int</italic>(<italic>&#x003bd;</italic>) is completely contained in [<italic>x</italic>:<italic>x</italic><sup>&#x02032;</sup>] whereas <italic>Int</italic>(<italic>parent</italic>(<italic>&#x003bd;</italic>)) is not contained in [<italic>x</italic>:<italic>x</italic><sup>&#x02032;</sup>]. The constructed balanced binary tree <italic>T</italic> is called a segment tree. This way of construction ensures non-overlapping, totally consecutive intervals for the nodes at any depth, from left to right. In other words, it provides a natural binning at any depth of the tree. In Fig.&#x000a0;<xref rid="Fig7" ref-type="fig">7</xref>, we exemplify how we store 4 intervals in the segment tree leaves and internal nodes which are constructed from the endpoints of these 4 given intervals. Moreover, in Fig.&#x000a0;<xref rid="Fig7" ref-type="fig">7</xref>, the arrows from the nodes point to their canonical subsets.
<fig id="Fig7"><label>Fig. 7</label><caption><p>Intervals (<italic>s</italic><sub>1</sub>,<italic>s</italic><sub>2</sub>,<italic>s</italic><sub>3</sub>,<italic>s</italic><sub>4</sub>) are stored in the nodes. The arrows from the nodes point to their canonical subsets</p></caption><graphic xlink:href="12859_2019_2698_Fig7_HTML" id="MO7"/></fig>
</p><sec id="Sec13"><title>Segment tree construction complexity analysis</title><p>To construct a segment tree for <italic>n</italic> given intervals, we proceed as follows: We sort the endpoints of <italic>n</italic> intervals in <italic>O</italic>(<italic>n</italic> log<italic>n</italic>) time and define elementary intervals at each end point and between each consecutive endpoints. We then construct a binary tree on these elementary intervals, where each interval is the union of its left and right child&#x02019;s intervals (or elementary intervals). This process continues until the extent of all of the intervals are represented by the root node. The construction can be done bottom-up in linear time. In the last phase, <italic>n</italic> given intervals are stored in the canonical subset of the nodes, when a node&#x02019;s interval, <italic>Int</italic>(<italic>&#x003bd;</italic>), is fully contained in an input interval. As a result, an interval can be attached to more than one node and the number of intervals attached to nodes decreases as we go up in the tree; since, a node&#x02019;s interval, <italic>Int</italic>(<italic>&#x003bd;</italic>), becomes larger as we get closer to the root node.</p></sec></sec><sec id="Sec14"><title>Segment tree query</title><p>A query is processed starting at the root node. If the query point <italic>q</italic><sub><italic>x</italic></sub> overlaps with the node&#x02019;s interval, <italic>Int</italic>(<italic>&#x003bd;</italic>), the associated intervals stored at that node, <italic>I</italic>(<italic>&#x003bd;</italic>), are output and the query continues on the left or right child of that node, visiting one node per level of the tree. The time complexity of a segment tree query is <italic>O</italic>(log<italic>n</italic>+<italic>k</italic>) where <italic>n</italic> is the number of intervals and <italic>k</italic> is the number of overlapping intervals in the segment tree for the query point <italic>q</italic><sub><italic>x</italic></sub> [<xref ref-type="bibr" rid="CR14">14</xref>].</p></sec><sec id="Sec15"><title>Indexed segment tree forest</title><p>After analyzing constructed segment trees for real data sets, we observed that nodes at the top of the segment tree (approximately top two thirds of the segment tree) do not store any intervals or store only a few intervals in their canonical subsets. In other words, input intervals are mostly stored in the bottom nodes of the segment tree.</p><p>Keeping the whole segment tree with a significant number of nodes without any or with a few intervals might be unnecessary. Furthermore, passing through all these nodes for each query in order to find overlapping intervals may increase the query time. Instead of having one tall segment tree, we can cut the segment tree at a certain depth close to the bottom of the tree and have as many short segment trees rooted at segment tree nodes present at this cut-off depth plus the segment tree nodes with no children above this cut-off depth.</p></sec><sec id="Sec16"><title>Indexed segment tree forest parameters</title><sec id="Sec17"><title>Cut-off depth</title><p>We decide on the cut-off depth by considering the total number of intervals stored in canonical subsets of nodes at the cut-off depth and above the cut-off depth. We find a depth, <italic>d</italic>, such that the number of intervals stored from root node to the nodes at this depth is greater than 0.5<italic>%</italic> of the total number of intervals stored in the segment tree. We then choose <italic>d</italic>+1 as the cut-off depth. The closer the cut-off depth to the bottom of the tree, the more segment trees there will be in the forest. In other words, cut-off depth determines the number of short segment trees in the forest.</p><p><bold>Moving intervals that were stored in the nodes above the cut-off depth:</bold> All the intervals attached to the nodes that are above the cut-off depth must be distributed to the nodes at the cut-off depth. Specifically, if an interval is attached to a node above the cut-off depth, then this interval must be attached to its offspring nodes at the cut-off depth. If there is no offspring node at the cut-off depth then there can be two cases. Case 1: If the node storing the interval has no offspring, then we directly add this node to our segment tree forest. Case 2: If the node has offspring/s above the cut-off depth, then we attach the interval to its lowest offspring nodes and add these lowest offspring nodes to our segment tree forest, with a higher priority given to the node closer to the cut-off depth in order to keep the order consistent between the intervals of the nodes. Note that we do this extra work for a small number of nodes.</p><p><bold>Linking segment tree nodes at the cut-off depth to each other:</bold> To ensure fast access between consecutive segment tree nodes at the cut-off depth, we connect segment tree nodes to each other through forward and backward pointers. We call these nodes linked nodes (See Fig.&#x000a0;<xref rid="Fig8" ref-type="fig">8</xref>).
<fig id="Fig8"><label>Fig. 8</label><caption><p>Segment tree nodes (blue) at the cut-off depth and segment tree nodes (red) with no children above the cut-off depth are stored in our segment tree forest. To enhance fast access, these stored segment tree nodes are connected to each other through forward and backward links</p></caption><graphic xlink:href="12859_2019_2698_Fig8_HTML" id="MO8"/></fig>
</p><p>As mentioned earlier, we cut the segment tree at the cut-off depth and keep the segment tree nodes at this cut-off depth and the nodes with no children above the cut-off depth in an indexed segment tree forest. Each segment tree node at this cut-off depth is in fact a root of a segment tree in the forest and we compute its hash index using a hash function for each segment tree node and we store [index,segment tree node] tuples in a map.</p></sec><sec id="Sec18"><title>Cut-off depth decision, percentage parameter</title><p>We make use of percentage parameter in cut-off depth decision. This percentage parameter determines the number of intervals that needs to be moved w.r.t. the total number of intervals stored in the segment tree. As this percentage parameter increases, the number of intervals that we accept to move increases, and we cut the original segment tree closer to the leaves. We analyzed how this percentage parameter affects the cut-off depth and how the cut-off depth affects the construction and query time. For this purpose, we used an input of 2.3 million intervals and varied the percentage parameter from 0.5 to 10.0. We observed that as we increase the percentage parameter, the number of intervals that need extra movement increases and the cut-off depth decreases, as expected (See Fig.&#x000a0;<xref rid="Fig3" ref-type="fig">3</xref>). In this context, cut-off depth is defined as depth from the leaf level. However, construction and query time increases slightly, most probably because of more individual nodes are added to the indexed segment tree forest data structure (See Fig.&#x000a0;<xref rid="Fig4" ref-type="fig">4</xref>). Based on these results, we decide on cut-off depth by considering movement of 0.5<italic>%</italic> of the total intervals. As a result, we internally set the percentage parameter to 0.5<italic>%</italic>.</p></sec><sec id="Sec19"><title>Hash function, preset value</title><p>To index the nodes at the cut-off depth we use one universal hash function as shown in Eq. <xref rid="Equ1" ref-type="">1</xref>. By using this hash function, we index these short segment trees and we access each short segment tree in <inline-formula id="IEq6"><alternatives><tex-math id="M11">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {O}(1)$\end{document}</tex-math><mml:math id="M12"><mml:mi mathvariant="script">O</mml:mi><mml:mo>(</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2019_2698_Article_IEq6.gif"/></alternatives></inline-formula> time instead of <inline-formula id="IEq7"><alternatives><tex-math id="M13">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {O}(cut-off)$\end{document}</tex-math><mml:math id="M14"><mml:mi mathvariant="script">O</mml:mi><mml:mo>(</mml:mo><mml:mtext mathvariant="italic">cut</mml:mtext><mml:mo>&#x02212;</mml:mo><mml:mtext mathvariant="italic">off</mml:mtext><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2019_2698_Article_IEq7.gif"/></alternatives></inline-formula> time. The preset value in the hash function determines the number of different hash indexes that one can have. 
<disp-formula id="Equ1"><label>1</label><alternatives><tex-math id="M15">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$  hashIndex = (node.interval.low/presetValue)  $$ \end{document}</tex-math><mml:math id="M16"><mml:mtext mathvariant="italic">hashIndex</mml:mtext><mml:mo>=</mml:mo><mml:mo>(</mml:mo><mml:mi>node.interval.low</mml:mi><mml:mo>/</mml:mo><mml:mtext mathvariant="italic">presetValue</mml:mtext><mml:mo>)</mml:mo></mml:math><graphic xlink:href="12859_2019_2698_Article_Equ1.gif" position="anchor"/></alternatives></disp-formula></p><p>Lower preset values result in many hash indexes with fewer segment trees with the same index, therefore, fewer collisions. But, lower preset values may result in sequential search of more than one segment tree, which is definitely not preferred. Conversely, higher preset values result in fewer hash indexes with more segment tree nodes with the same index, which implies more collisions. To efficiently handle collisions, we construct a binary search tree (BST) from the segment tree nodes with the same index and store the root of this BST in the hash map. Parent nodes of these linked nodes in the BST constitute the artificial nodes as shown in Fig.&#x000a0;<xref rid="Fig9" ref-type="fig">9</xref>.
<fig id="Fig9"><label>Fig. 9</label><caption><p>Segment tree nodes with the same index are stored in a BST and the root of BST is indexed. Blue and red colored nodes are original segment tree nodes which are linked to each other. Blue colored nodes are in fact the roots of the segment trees below them. Red colored nodes do not have any children. Parents of these blue and red colored nodes are the artificial nodes, if any</p></caption><graphic xlink:href="12859_2019_2698_Fig9_HTML" id="MO9"/></fig>
</p><p>This collision handling strategy implies that each segment tree may be reached in <inline-formula id="IEq8"><alternatives><tex-math id="M17">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {O}(height(BST))$\end{document}</tex-math><mml:math id="M18"><mml:mi mathvariant="script">O</mml:mi><mml:mo>(</mml:mo><mml:mtext mathvariant="italic">height</mml:mtext><mml:mo>(</mml:mo><mml:mtext mathvariant="italic">BST</mml:mtext><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2019_2698_Article_IEq8.gif"/></alternatives></inline-formula> time instead of <inline-formula id="IEq9"><alternatives><tex-math id="M19">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$\mathcal {O}(height(OriginalSegmentTree))$\end{document}</tex-math><mml:math id="M20"><mml:mi mathvariant="script">O</mml:mi><mml:mo>(</mml:mo><mml:mtext mathvariant="italic">height</mml:mtext><mml:mo>(</mml:mo><mml:mtext mathvariant="italic">OriginalSegmentTree</mml:mtext><mml:mo>)</mml:mo><mml:mo>)</mml:mo></mml:math><inline-graphic xlink:href="12859_2019_2698_Article_IEq9.gif"/></alternatives></inline-formula> time. As long as the height of BST formed from these segment trees with the same index is less than the height of the original segment tree, search in indexed segment tree forest will be still less than search in one tall segment tree.</p><p>Theoretically, when all the nodes at the cut-off depth have the same hash index; the same segment tree will be constructed for them. Therefore, the height of the hash BST will be always less than or equal to the height of the original segment tree. To exemplify this situation, we carried out an analysis by using inputs of 2.3 million intervals. We observed that average height of the hash BST is less than the average height of the original segment tree for each chromosome. We also averaged over all chromosomes and showed that the average height of hash BSTs is 12.9 and the average height of the original segment tree is 19.4 for varying percentages from 0.5 to 10 and for the preset value of 1000000 as shown in Table&#x000a0;<xref rid="Tab8" ref-type="table">8</xref>.
<table-wrap id="Tab8"><label>Table 8</label><caption><p>Average height of hash BSTs and original segment tree for all chromosomes are presented</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left"/><th align="left" colspan="2">Average Height</th></tr><tr><th align="left">Percentage</th><th align="left">Hash BSTs</th><th align="left">Original Segment Tree</th></tr></thead><tbody><tr><td align="left">0.5</td><td align="left">12.9695</td><td align="left">19.4</td></tr><tr><td align="left">1.0</td><td align="left">12.9823</td><td align="left"/></tr><tr><td align="left">1.5</td><td align="left">12.9842</td><td align="left"/></tr><tr><td align="left">2.0</td><td align="left">12.9838</td><td align="left"/></tr><tr><td align="left">2.5</td><td align="left"/><td align="left"/></tr><tr><td align="left">3.0</td><td align="left">12.9842</td><td align="left"/></tr><tr><td align="left">3.5</td><td align="left">12.9845</td><td align="left"/></tr><tr><td align="left">4.0</td><td align="left"/><td align="left"/></tr><tr><td align="left">4.5</td><td align="left"/><td align="left"/></tr><tr><td align="left">5.0</td><td align="left">12.9843</td><td align="left"/></tr><tr><td align="left">5.5</td><td align="left"/><td align="left"/></tr><tr><td align="left">6.0</td><td align="left">12.9845</td><td align="left"/></tr><tr><td align="left">6.5</td><td align="left">12.9831</td><td align="left"/></tr><tr><td align="left">7.0</td><td align="left">12.9821</td><td align="left"/></tr><tr><td align="left">7.5</td><td align="left"/><td align="left"/></tr><tr><td align="left">8.0</td><td align="left">12.9814</td><td align="left"/></tr><tr><td align="left">8.5</td><td align="left"/><td align="left"/></tr><tr><td align="left">9.0</td><td align="left"/><td align="left"/></tr><tr><td align="left">9.5</td><td align="left"/><td align="left"/></tr><tr><td align="left">10.0</td><td align="left"/><td align="left"/></tr></tbody></table><table-wrap-foot><p>While preset value of 1000000 is kept constant, percentage parameter used in cut-off depth decision is varied from 0.5 to 10.0, and average height of hash BSTs and original segment tree are found using 2.3 million intervals files. It is observed that average height of hash BSTs are always less than the average height of the original segment tree</p></table-wrap-foot></table-wrap>
</p></sec></sec><sec id="Sec20"><title>Query in indexed segment tree forest</title><p>For each query interval, we compute its <italic>lowIndex</italic> and <italic>highIndex</italic> using its low and high endpoints, respectively. We start searching on a linked node pointed by the <italic>lowIndex</italic> if it exists, otherwise we find the <italic>lowerIndex</italic> (highest index lower than <italic>lowIndex</italic>) and start searching at the node shown by the <italic>lowerIndex</italic> and continue searching forward. If it is not possible, we start searching on the linked node pointed by the <italic>highIndex</italic> if it exists, if not, we compute <italic>higherIndex</italic> (lowest index higher than <italic>highIndex</italic>) and search the node pointed by <italic>higherIndex</italic> and continue searching backward. If there is no node pointed by <italic>higherIndex</italic>, it means that there is no overlapping interval with the query interval. The pseudocode of the indexed segment tree forest search algorithms are provided in the Additional file&#x000a0;<xref rid="MOESM2" ref-type="media">2</xref>.</p><sec id="Sec21"><title>How to guarantee that at most two additional index searches are enough?</title><p>As it is shown in Fig.&#x000a0;<xref rid="Fig10" ref-type="fig">10</xref>, we first compute <italic>lowIndex</italic><sub><italic>i</italic></sub> and <italic>highIndex</italic><sub><italic>j</italic></sub> using query low and high endpoints, respectively. Then we search for the segment trees pointed by one of these indexes in the order of <italic>lowIndex</italic><sub><italic>i</italic></sub>, <italic>lowIndex</italic><sub><italic>i</italic>&#x02212;1</sub>, <italic>highIndex</italic><sub><italic>j</italic></sub> or <italic>highIndex</italic><sub><italic>j</italic>+1</sub>.
<fig id="Fig10"><label>Fig. 10</label><caption><p>Searching the nodes pointed by <italic>lowIndex</italic><sub><italic>i</italic></sub> and <italic>highIndex</italic><sub><italic>j</italic></sub>, the nodes in between them, and plus two more nodes at most is enough</p></caption><graphic xlink:href="12859_2019_2698_Fig10_HTML" id="MO10"/></fig>
</p><p>Here we present why we may need to consider only two more segment trees pointed by the indexes <italic>lowIndex</italic><sub><italic>i</italic>&#x02212;1</sub> and the <italic>highIndex</italic><sub><italic>j</italic>+1</sub> (Fig.&#x000a0;<xref rid="Fig10" ref-type="fig">10</xref>). 
<disp-formula id="Equ2"><label>2</label><alternatives><tex-math id="M21">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ {lowIndex}_{i}=queryLow/presetValue  $$ \end{document}</tex-math><mml:math id="M22"><mml:msub><mml:mrow><mml:mtext mathvariant="italic">lowIndex</mml:mtext></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mtext mathvariant="italic">queryLow</mml:mtext><mml:mo>/</mml:mo><mml:mtext mathvariant="italic">presetValue</mml:mtext></mml:math><graphic xlink:href="12859_2019_2698_Article_Equ2.gif" position="anchor"/></alternatives></disp-formula></p><p>
<disp-formula id="Equ3"><label>3</label><alternatives><tex-math id="M23">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ {highIndex}_{j}=queryHigh/presetValue  $$ \end{document}</tex-math><mml:math id="M24"><mml:msub><mml:mrow><mml:mtext mathvariant="italic">highIndex</mml:mtext></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mtext mathvariant="italic">queryHigh</mml:mtext><mml:mo>/</mml:mo><mml:mtext mathvariant="italic">presetValue</mml:mtext></mml:math><graphic xlink:href="12859_2019_2698_Article_Equ3.gif" position="anchor"/></alternatives></disp-formula>
</p><p>
<disp-formula id="Equ4"><label>4</label><alternatives><tex-math id="M25">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ {lowIndex}_{i-2} &#x0003c; {lowIndex}_{i-1} &#x0003c; {lowIndex}_{i}  $$ \end{document}</tex-math><mml:math id="M26"><mml:msub><mml:mrow><mml:mtext mathvariant="italic">lowIndex</mml:mtext></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>&#x0003c;</mml:mo><mml:msub><mml:mrow><mml:mtext mathvariant="italic">lowIndex</mml:mtext></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>&#x0003c;</mml:mo><mml:msub><mml:mrow><mml:mtext mathvariant="italic">lowIndex</mml:mtext></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:math><graphic xlink:href="12859_2019_2698_Article_Equ4.gif" position="anchor"/></alternatives></disp-formula>
</p><p>
<disp-formula id="Equ5"><label>5</label><alternatives><tex-math id="M27">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ {lowIndex}_{i-1} &#x0003c; {lowIndex}_{i} \Rightarrow  $$ \end{document}</tex-math><mml:math id="M28"><mml:msub><mml:mrow><mml:mtext mathvariant="italic">lowIndex</mml:mtext></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>&#x0003c;</mml:mo><mml:msub><mml:mrow><mml:mtext mathvariant="italic">lowIndex</mml:mtext></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&#x021d2;</mml:mo></mml:math><graphic xlink:href="12859_2019_2698_Article_Equ5.gif" position="anchor"/></alternatives></disp-formula>
</p><p>
<disp-formula id="Equ6"><label>6</label><alternatives><tex-math id="M29">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$  {lowNode}_{i-1}.interval.low &#x0003c; queryLow  $$ \end{document}</tex-math><mml:math id="M30"><mml:msub><mml:mrow><mml:mtext mathvariant="italic">lowNode</mml:mtext></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mi>.interval.low</mml:mi><mml:mo>&#x0003c;</mml:mo><mml:mtext mathvariant="italic">queryLow</mml:mtext></mml:math><graphic xlink:href="12859_2019_2698_Article_Equ6.gif" position="anchor"/></alternatives></disp-formula>
</p><p>From the preserved order between intervals of consecutive nodes we know that 
<disp-formula id="Equ7"><label>7</label><alternatives><tex-math id="M31">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ \begin{aligned} {lowNode}_{i-2}.interval.high &#x0003c; \\ {lowNode}_{i-1}.interval.low \end{aligned}  $$ \end{document}</tex-math><mml:math id="M32"><mml:mtable><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mtext mathvariant="italic">lowNode</mml:mtext></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mi>.interval.high</mml:mi><mml:mo>&#x0003c;</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msub><mml:mrow><mml:mtext mathvariant="italic">lowNode</mml:mtext></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mi>.interval.low</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="12859_2019_2698_Article_Equ7.gif" position="anchor"/></alternatives></disp-formula></p><p>Equations <xref rid="Equ6" ref-type="">6</xref> and <xref rid="Equ7" ref-type="">7</xref> imply that 
<disp-formula id="Equ8"><label>8</label><alternatives><tex-math id="M33">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document} $$ {lowNode}_{i-2}.interval.high &#x0003c; queryLow   $$ \end{document}</tex-math><mml:math id="M34"><mml:msub><mml:mrow><mml:mtext mathvariant="italic">lowNode</mml:mtext></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mi>.interval.high</mml:mi><mml:mo>&#x0003c;</mml:mo><mml:mtext mathvariant="italic">queryLow</mml:mtext></mml:math><graphic xlink:href="12859_2019_2698_Article_Equ8.gif" position="anchor"/></alternatives></disp-formula></p><p>As a result of inequality Eq. <xref rid="Equ8" ref-type="">8</xref>, <italic>lowNode</italic><sub><italic>i</italic>&#x02212;2</sub>.<italic>interval</italic> and query interval can not overlap. Therefore we may need to look at only one more index preceding the <italic>lowIndex</italic><sub><italic>i</italic></sub> and search for the segment tree pointed by that index and forward. In the same manner, we may need to consider only one more index subsequent to the <italic>highIndex</italic><sub><italic>j</italic></sub> and search for the segment tree pointed by that index and backward.</p></sec></sec><sec id="Sec22"><title>Real datasets: benchmarks</title><p>We defined six benchmarks, which are listed in Table&#x000a0;<xref rid="Tab1" ref-type="table">1</xref> for execution time comparisons of the tools.</p><p>The first two benchmarks include five files containing DNase-Hypersensitivity hotspot peaks from mouse fetal tissues: fAdrenal-DS12528, fAdrenal-DS15123, fAdrenal-DS17319, fAdrenal-DS17677 and fAdrenal-DS20343. They contain 193835, 188966, 137386, 132500, and 195098 intervals, respectively. The first benchmark that is called &#x0201c;2 small files&#x0201d; is a subset containing the first two of the five files, whereas the second benchmark named as &#x0201c;5 small files&#x0201d; is the set of all five files.</p><p>The last four benchmarks come from three files consisting of histone modifications from human cell lines: HepG2, Dnd41 and A459 including 2,362,386 (2.3M), 6,473,749 (6.4M), and 9,218,913 (9.2M) intervals, respectively. The last benchmark is a subset containing the last two of these files. Sources of these benchmark datasets are provided in Availability of data and material.</p></sec></sec><sec sec-type="supplementary-material"><title>Additional files</title><sec id="Sec23"><p>
<supplementary-material content-type="local-data" id="MOESM1"><media xlink:href="12859_2019_2698_MOESM1_ESM.xlsx"><label>Additional file 1</label><caption><p>Supplementary Table S1 contains all jointly overlapping intervals for 141 interval sets of Dnase hypersensitive sites. (XLSX 75 kb)</p></caption></media></supplementary-material>
</p><p>
<supplementary-material content-type="local-data" id="MOESM2"><media xlink:href="12859_2019_2698_MOESM2_ESM.pdf"><label>Additional file 2</label><caption><p>Supplementary Material includes Supplementary Tables S2 and S3 for memory usage of JOA ST and ISTF for the semi-synthetic datasets. Supplementary Material also provides the pseudocode of the indexed segment tree forest search algorithms. (PDF 135 kb)</p></caption></media></supplementary-material>
</p></sec></sec></body><back><glossary><title>Abbreviations</title><def-list><def-item><term>NGS</term><def><p>Next Generation Sequencing</p></def></def-item><def-item><term>JOA</term><def><p>Joint Overlap Analysis</p></def></def-item><def-item><term>ST</term><def><p>Segment Tree</p></def></def-item><def-item><term>ISTF</term><def><p>Indexed Segment Tree Forest</p></def></def-item></def-list></glossary><fn-group><fn><p><bold>Availability of data and materials</bold></p><p>JOA&#x02019;s source code is available at <ext-link ext-link-type="uri" xlink:href="https://github.com/burcakotlu/JOA/">https://github.com/burcakotlu/JOA/</ext-link>. You can download JOA executable jar, joa.jar from <ext-link ext-link-type="uri" xlink:href="http://burcak.ceng.metu.edu.tr/joa/">http://burcak.ceng.metu.edu.tr/joa/</ext-link>. A user manual is provided at <ext-link ext-link-type="uri" xlink:href="https://joa.readthedocs.org">https://joa.readthedocs.org</ext-link>.</p><p>Benchmark Datasets: The first two benchmarks &#x0201c;2 small files&#x0201d; and &#x0201c;5 small files&#x0201d; are obtained from five files: fAdrenal-DS12528, fAdrenal-DS15123, fAdrenal-DS17319, fAdrenal-DS17677 and fAdrenal-DS20343. They are all in bed format and available for download from <ext-link ext-link-type="uri" xlink:href="http://burcak.ceng.metu.edu.tr/joa/">http://burcak.ceng.metu.edu.tr/joa/</ext-link>. The last four benchmarks (2.3M,2.3M),(6.4M,6.4M), (9.2M,9.2M) and (6.4M,9.2M) come from three files: 2.3M (wgEncodeBroadHistoneHepg2CtcfStdAlnRep1), 6.4M (wgEncodeBroadHistoneDnd41H3k04me2AlnRep2), 9.2M (wgEncodeBroadHistoneA549H3k04me2Dex100nmAlnRep2). They are downloaded as bam format files from <ext-link ext-link-type="uri" xlink:href="http://hgdownload.cse.ucsc.edu/goldenpath/hg19/encodeDCC/wgEncodeBroadHistone/">http://hgdownload.cse.ucsc.edu/goldenpath/hg19/encodeDCC/wgEncodeBroadHistone/</ext-link> and converted into bed format files.</p><p>Semi-Synthetic Dataset: All files are in bed format. Compressed simulated_data.tar.gz file can be downloaded from <ext-link ext-link-type="uri" xlink:href="http://burcak.ceng.metu.edu.tr/joa/">http://burcak.ceng.metu.edu.tr/joa/</ext-link>.</p><p>ENCODE Data: For additional case study of JOA, we downloaded 141 interval sets of ENCODE Dnase hypersensitive sites (29 of them are in pk format and 112 of them are in bed format) from <ext-link ext-link-type="uri" xlink:href="http://hgdownload.cse.ucsc.edu/goldenpath/hg19/encodeDCC/wgEncodeUwDnase/">http://hgdownload.cse.ucsc.edu/goldenpath/hg19/encodeDCC/wgEncodeUwDnase/</ext-link>
and <ext-link ext-link-type="uri" xlink:href="http://hgdownload.cse.ucsc.edu/goldenpath/hg19/encodeDCC/wgEncodeOpenChromDnase/">http://hgdownload.cse.ucsc.edu/goldenpath/hg19/encodeDCC/wgEncodeOpenChromDnase/</ext-link>.</p></fn></fn-group><ack><title>Acknowledgements</title><p>Not applicable.</p><sec id="d29e3303"><title>Funding</title><p>No funding was received for the study.</p></sec></ack><notes notes-type="author-contribution"><title>Authors&#x02019; contributions</title><p>BO conceived the idea of indexed segment tree forest, designed and implemented the parallel algorithms for segment tree and indexed segment tree forest, conducted execution time comparison analysis. TC supervised the project and execution time comparison analysis. BO and TC wrote the manuscript. All authors read and approved the final manuscript.</p></notes><notes notes-type="COI-statement"><sec><title>Ethics approval and consent to participate</title><p>Not applicable.</p></sec><sec><title>Consent for publication</title><p>Not applicable.</p></sec><sec><title>Competing interests</title><p>The authors declare that they have no competing interests.</p></sec><sec><title>Publisher&#x02019;s Note</title><p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p></sec></notes><ref-list id="Bib1"><title>References</title><ref id="CR1"><label>1</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Speir</surname><given-names>ML</given-names></name><name><surname>Zweig</surname><given-names>AS</given-names></name><name><surname>Rosenbloom</surname><given-names>KR</given-names></name><name><surname>Raney</surname><given-names>BJ</given-names></name><name><surname>Paten</surname><given-names>B</given-names></name><name><surname>Nejad</surname><given-names>P</given-names></name><name><surname>Lee</surname><given-names>BT</given-names></name><name><surname>Learned</surname><given-names>K</given-names></name><name><surname>Karolchik</surname><given-names>D</given-names></name><name><surname>Hinrichs</surname><given-names>AS</given-names></name><name><surname>Heitner</surname><given-names>S</given-names></name><name><surname>Harte</surname><given-names>RA</given-names></name><name><surname>Haeussler</surname><given-names>M</given-names></name><name><surname>Guruvadoo</surname><given-names>L</given-names></name><name><surname>Fujita</surname><given-names>PA</given-names></name><name><surname>Eisenhart</surname><given-names>C</given-names></name><name><surname>Diekhans</surname><given-names>M</given-names></name><name><surname>Clawson</surname><given-names>H</given-names></name><name><surname>Casper</surname><given-names>J</given-names></name><name><surname>Barber</surname><given-names>GP</given-names></name><name><surname>Haussler</surname><given-names>D</given-names></name><name><surname>Kuhn</surname><given-names>RM</given-names></name><name><surname>Kent</surname><given-names>WJ</given-names></name></person-group><article-title>The UCSC Genome Browser database: 2016 update,</article-title><source>Nucleic Acids Res</source><year>2016</year><volume>44</volume><issue>D1</issue><fpage>717</fpage><lpage>25</lpage><pub-id pub-id-type="doi">10.1093/nar/gkv1275</pub-id></element-citation></ref><ref id="CR2"><label>2</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Quinlan</surname><given-names>AR</given-names></name><name><surname>Hall</surname><given-names>IM</given-names></name></person-group><article-title>BEDTools: a flexible suite of utilities for comparing genomic features</article-title><source>Bioinformatics</source><year>2010</year><volume>26</volume><issue>6</issue><fpage>841</fpage><lpage>2</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btq033</pub-id><pub-id pub-id-type="pmid">20110278</pub-id></element-citation></ref><ref id="CR3"><label>3</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Dale</surname><given-names>RK</given-names></name><name><surname>Pedersen</surname><given-names>BS</given-names></name><name><surname>Quinlan</surname><given-names>AR</given-names></name></person-group><article-title>Pybedtools: a flexible python library for manipulating genomic datasets and annotations</article-title><source>Bioinformatics</source><year>2011</year><volume>27</volume><issue>24</issue><fpage>3423</fpage><lpage>24</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btr539</pub-id><pub-id pub-id-type="pmid">21949271</pub-id></element-citation></ref><ref id="CR4"><label>4</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Neph</surname><given-names>S</given-names></name><name><surname>Kuehn</surname><given-names>MS</given-names></name><name><surname>Reynolds</surname><given-names>AP</given-names></name><name><surname>Haugen</surname><given-names>E</given-names></name><name><surname>Thurman</surname><given-names>RE</given-names></name><name><surname>Johnson</surname><given-names>AK</given-names></name><name><surname>Rynes</surname><given-names>E</given-names></name><name><surname>Maurano</surname><given-names>MT</given-names></name><name><surname>Vierstra</surname><given-names>J</given-names></name><name><surname>Thomas</surname><given-names>S</given-names></name><name><surname>Sandstrom</surname><given-names>R</given-names></name><name><surname>Humbert</surname><given-names>R</given-names></name><name><surname>Stamatoyannopoulos</surname><given-names>JA</given-names></name></person-group><article-title>BEDOPS: high-performance genomic feature operations</article-title><source>Bioinformatics</source><year>2012</year><volume>28</volume><issue>14</issue><fpage>1919</fpage><lpage>20</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/bts277</pub-id><pub-id pub-id-type="pmid">22576172</pub-id></element-citation></ref><ref id="CR5"><label>5</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Ovaska</surname><given-names>K</given-names></name><name><surname>Lyly</surname><given-names>L</given-names></name><name><surname>Sahu</surname><given-names>B</given-names></name><name><surname>Janne</surname><given-names>OA</given-names></name><name><surname>Hautaniemi</surname><given-names>S</given-names></name></person-group><article-title>Genomic region operation kit for flexible processing of deep sequencing data</article-title><source>IEEE/ACM Trans Comput Biol Bioinforma</source><year>2013</year><volume>10</volume><issue>1</issue><fpage>200</fpage><lpage>6</lpage><pub-id pub-id-type="doi">10.1109/TCBB.2012.170</pub-id></element-citation></ref><ref id="CR6"><label>6</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Alekseyenko</surname><given-names>AV</given-names></name><name><surname>Lee</surname><given-names>CJ</given-names></name></person-group><article-title>Nested Containment List (NCList): a new algorithm for accelerating interval query of genome alignment and interval databases</article-title><source>Bioinformatics (Oxford, England)</source><year>2007</year><volume>23</volume><issue>11</issue><fpage>1386</fpage><lpage>93</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btl647</pub-id></element-citation></ref><ref id="CR7"><label>7</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Otlu</surname><given-names>B</given-names></name><name><surname>Firtina</surname><given-names>C</given-names></name><name><surname>Kele&#x0015f;</surname><given-names>S</given-names></name><name><surname>Tastan</surname><given-names>O</given-names></name></person-group><article-title>Glanet: genomic loci annotation and enrichment tool</article-title><source>Bioinformatics</source><year>2017</year><volume>33</volume><issue>18</issue><fpage>2818</fpage><lpage>28</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btx326</pub-id><pub-id pub-id-type="pmid">28541490</pub-id></element-citation></ref><ref id="CR8"><label>8</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Layer</surname><given-names>RM</given-names></name><name><surname>Quinlan</surname><given-names>AR</given-names></name></person-group><article-title>A parallel algorithm for n -way interval set intersection</article-title><source>Proc IEEE</source><year>2015</year><volume>PP</volume><issue>99</issue><fpage>1</fpage><lpage>10</lpage><pub-id pub-id-type="doi">10.1109/JPROC.2015.2461494</pub-id></element-citation></ref><ref id="CR9"><label>9</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>H</given-names></name></person-group><article-title>Tabix: fast retrieval of sequence features from generic TAB-delimited files</article-title><source>Bioinformatics</source><year>2011</year><volume>27</volume><issue>5</issue><fpage>718</fpage><lpage>9</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btq671</pub-id><pub-id pub-id-type="pmid">21208982</pub-id></element-citation></ref><ref id="CR10"><label>10</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>H</given-names></name></person-group><article-title>Bgt: efficient and flexible genotype query across many samples</article-title><source>Bioinformatics</source><year>2016</year><volume>32</volume><issue>4</issue><fpage>590</fpage><lpage>2</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btv613</pub-id><pub-id pub-id-type="pmid">26500154</pub-id></element-citation></ref><ref id="CR11"><label>11</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Layer</surname><given-names>RM</given-names></name><name><surname>Kindlon</surname><given-names>N</given-names></name><name><surname>Karczewski</surname><given-names>KJ</given-names></name><name><surname>ExAC</surname><given-names>EAC</given-names></name><name><surname>Quinlan</surname><given-names>AR</given-names></name></person-group><article-title>Efficient compression and analysis of large genetic variation datasets</article-title><source>Nat Methods</source><year>2015</year><volume>13</volume><fpage>63</fpage><lpage>5</lpage><pub-id pub-id-type="doi">10.1038/nmeth.3654</pub-id><pub-id pub-id-type="pmid">26550772</pub-id></element-citation></ref><ref id="CR12"><label>12</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Zheng</surname><given-names>X</given-names></name><name><surname>Gogarten</surname><given-names>SM</given-names></name><name><surname>Lawrence</surname><given-names>M</given-names></name><name><surname>Stilp</surname><given-names>A</given-names></name><name><surname>Conomos</surname><given-names>MP</given-names></name><name><surname>Weir</surname><given-names>BS</given-names></name><name><surname>Laurie</surname><given-names>C</given-names></name><name><surname>Levine</surname><given-names>D</given-names></name></person-group><article-title>Seqarray&#x02014;a storage-efficient high-performance data format for wgs variant calls</article-title><source>Bioinformatics</source><year>2017</year><volume>33</volume><issue>15</issue><fpage>2251</fpage><lpage>7</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btx145</pub-id><pub-id pub-id-type="pmid">28334390</pub-id></element-citation></ref><ref id="CR13"><label>13</label><mixed-citation publication-type="other">Band G, Marchini J. Bgen: a binary file format for imputed genotype and haplotype data. bioRxiv. 2018. 10.1101/308296. <ext-link ext-link-type="uri" xlink:href="https://www.biorxiv.org/content/early/2018/05/02/308296.full.pdf">https://www.biorxiv.org/content/early/2018/05/02/308296.full.pdf</ext-link>.</mixed-citation></ref><ref id="CR14"><label>14</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>de Berg</surname><given-names>M</given-names></name><name><surname>Cheong</surname><given-names>O</given-names></name><name><surname>van Kreveld</surname><given-names>M</given-names></name><name><surname>Overmars</surname><given-names>M</given-names></name></person-group><source>Computational Geometry: Algorithms and Applications. 3rd ed. 2008</source><year>2010</year><publisher-loc>Berlin</publisher-loc><publisher-name>Springer</publisher-name></element-citation></ref></ref-list></back></article>